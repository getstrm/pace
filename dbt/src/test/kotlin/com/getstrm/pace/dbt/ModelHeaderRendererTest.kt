package com.getstrm.pace.dbt

import build.buf.gen.getstrm.pace.api.entities.v1alpha.DataPolicyKt.target
import build.buf.gen.getstrm.pace.api.entities.v1alpha.ProcessingPlatform
import build.buf.gen.getstrm.pace.api.entities.v1alpha.processingPlatform
import build.buf.gen.getstrm.pace.api.entities.v1alpha.resourceNode
import build.buf.gen.getstrm.pace.api.entities.v1alpha.resourceUrn
import io.kotest.matchers.shouldBe
import org.junit.jupiter.api.Test

class ModelHeaderRendererTest {

    private val minimalDbtModel =
        DbtModel(
            database = "my_db",
            schema = "my_schema",
            name = "my_model",
        )

    @Test
    fun `basic policy with same db and schema as source`() {
        // Given
        val target = target {
            ref = resourceUrn {
                resourcePath.addAll(
                    listOf(
                            "my_db",
                            "my_schema",
                            "my_model",
                        )
                        .map { resourceNode { name = it } },
                )
            }
        }

        // When
        val header = ModelHeaderRenderer(minimalDbtModel, target).render()

        // Then
        header shouldBe
            """
            {#
                This file was auto-generated by PACE. Do not edit this file directly.
            #}
            {{
                config(
                  materialized='view',
                  meta={'pace_generated': true}
                )
            }}
        
        """
                .trimIndent()
    }

    @Test
    fun `when the target db or schema differ from the source, they must be specified in the config`() {
        // Given
        val target = target {
            ref = resourceUrn {
                resourcePath.addAll(
                    listOf(
                            "my_other_db",
                            "my_other_schema",
                            "my_model",
                        )
                        .map { resourceNode { name = it } },
                )
            }
        }

        // When
        val header = ModelHeaderRenderer(minimalDbtModel, target).render()

        // Then
        header shouldBe
            """
            {#
                This file was auto-generated by PACE. Do not edit this file directly.
            #}
            {{
                config(
                  materialized='view',
                  meta={'pace_generated': true},
                  database='my_other_db',
                  schema='my_other_schema'
                )
            }}
        
        """
                .trimIndent()
    }

    @Test
    fun `when the target platform is BigQuery and the target schema is different from the source, the view should be authorized to read from the source dataset`() {
        // Given
        val target = target {
            ref = resourceUrn {
                platform = processingPlatform {
                    platformType = ProcessingPlatform.PlatformType.BIGQUERY
                }
                resourcePath.addAll(
                    listOf(
                            "my_db",
                            "my_other_schema",
                            "my_model",
                        )
                        .map { resourceNode { name = it } },
                )
            }
        }

        // When
        val header = ModelHeaderRenderer(minimalDbtModel, target).render()

        // Then
        header shouldBe
            """
            {#
                This file was auto-generated by PACE. Do not edit this file directly.
            #}
            {{
                config(
                  materialized='view',
                  meta={'pace_generated': true},
                  schema='my_other_schema',
                  grant_access_to=[
                    {'project': 'my_db', 'dataset': 'my_schema'}
                  ]
                )
            }}
        
        """
                .trimIndent()
    }

    @Test
    fun `when the target platform is BigQuery and the target schema is identical to the source schema, no granting needs to be done`() {
        // Given
        val target = target {
            ref = resourceUrn {
                platform = processingPlatform {
                    platformType = ProcessingPlatform.PlatformType.BIGQUERY
                }
                resourcePath.addAll(
                    listOf(
                            "my_db",
                            "my_schema",
                            "my_model",
                        )
                        .map { resourceNode { name = it } },
                )
            }
        }

        // When
        val header = ModelHeaderRenderer(minimalDbtModel, target).render()

        // Then
        header shouldBe
            """
            {#
                This file was auto-generated by PACE. Do not edit this file directly.
            #}
            {{
                config(
                  materialized='view',
                  meta={'pace_generated': true}
                )
            }}
        
        """
                .trimIndent()
    }
}
